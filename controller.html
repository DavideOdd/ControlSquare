<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Control Square - Controller</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="controller-container">
    <!-- Header -->
    <div class="header">
      <h1>â¬› Control Square</h1>
      <p>Sistema di controllo centralizzato per display multipli</p>
      <div class="connection-status">
        <div id="connectionIndicator" class="status-indicator"></div>
        <span id="connectionText">Disconnesso</span>
      </div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel">
      <div class="control-section">
        <h3>ModalitÃ  Controllo</h3>
        <div class="control-modes">
          <button class="mode-btn active" data-mode="global" title="Controlla tutti i display">
            ğŸŒ Globale
          </button>
          <button class="mode-btn" data-mode="multiple" title="Seleziona display specifici">
            â˜‘ï¸ Multiplo
          </button>
          <button class="mode-btn" data-mode="single" title="Click su un display per controllarlo">
            ğŸ‘† Singolo
          </button>
        </div>
      </div>

      <div class="control-section">
        <h3>Controllo Colore</h3>
        <div class="control-group">
          <div class="color-picker-container">
            <div class="color-input-wrapper">
              <input type="color" id="globalColorPicker" value="#6366f1">
              <input type="text" id="colorHexInput" value="#6366f1" placeholder="#000000" maxlength="7">
            </div>
            <button class="btn btn-primary" id="applyColorBtn">
              Applica Colore
            </button>
          </div>
        </div>
      </div>

      <div class="control-section">
        <h3>Preset Colori</h3>
        <div class="preset-colors">
          <div class="preset-color" style="background-color: #ef4444;" data-color="#ef4444" title="Rosso"></div>
          <div class="preset-color" style="background-color: #f59e0b;" data-color="#f59e0b" title="Arancione"></div>
          <div class="preset-color" style="background-color: #eab308;" data-color="#eab308" title="Giallo"></div>
          <div class="preset-color" style="background-color: #22c55e;" data-color="#22c55e" title="Verde"></div>
          <div class="preset-color" style="background-color: #06b6d4;" data-color="#06b6d4" title="Ciano"></div>
          <div class="preset-color" style="background-color: #3b82f6;" data-color="#3b82f6" title="Blu"></div>
          <div class="preset-color" style="background-color: #6366f1;" data-color="#6366f1" title="Indaco"></div>
          <div class="preset-color" style="background-color: #a855f7;" data-color="#a855f7" title="Viola"></div>
          <div class="preset-color" style="background-color: #ec4899;" data-color="#ec4899" title="Rosa"></div>
          <div class="preset-color" style="background-color: #ffffff;" data-color="#ffffff" title="Bianco"></div>
          <div class="preset-color" style="background-color: #000000;" data-color="#000000" title="Nero"></div>
        </div>
      </div>

      <div class="control-section">
        <h3>Azioni</h3>
        <div class="control-group">
          <button class="btn btn-secondary" id="exportConfigBtn">
            ğŸ“¤ Esporta Config
          </button>
          <button class="btn btn-secondary" id="importConfigBtn">
            ğŸ“¥ Importa Config
          </button>
          <button class="btn btn-success" id="saveSceneBtn">
            ğŸ’¾ Salva Scena
          </button>
          <button class="btn btn-warning" id="refreshDisplaysBtn">
            ğŸ”„ Aggiorna Display
          </button>
        </div>
      </div>
    </div>

    <!-- Scenes Panel -->
    <div class="scenes-panel">
      <h3>Scene Salvate</h3>
      <div class="scenes-list" id="scenesList">
        <div class="empty-state" id="scenesEmptyState">
          <p>Nessuna scena salvata. Crea una scena per salvare la configurazione corrente dei display.</p>
        </div>
      </div>
    </div>

    <!-- Displays Grid -->
    <div class="displays-container">
      <h2>
        Display Connessi
        <span class="display-count" id="displayCount">0</span>
      </h2>

      <div class="displays-grid" id="displaysGrid">
        <div class="empty-state" id="emptyState">
          <div class="empty-state-icon">ğŸ“±</div>
          <h3>Nessun display connesso</h3>
          <p>Apri la pagina display su uno o piÃ¹ dispositivi per iniziare</p>
          <a href="/display" class="btn btn-primary" target="_blank">
            Apri Display
          </a>
        </div>
      </div>
    </div>

    <!-- Command Log -->
    <div class="command-log">
      <h3>Log Comandi</h3>
      <div class="log-entries" id="logEntries">
        <p style="color: var(--text-secondary); text-align: center;">Nessun comando eseguito</p>
      </div>
    </div>
  </div>

  <!-- Modal Rename Display -->
  <div id="renameModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Rinomina Display</h2>
        <button class="close-modal" onclick="closeRenameModal()">&times;</button>
      </div>
      <div class="form-group">
        <label for="newDisplayName">Nuovo Nome:</label>
        <input type="text" id="newDisplayName" placeholder="Es: Tablet Cucina">
      </div>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="closeRenameModal()">Annulla</button>
        <button class="btn btn-primary" onclick="confirmRename()">Salva</button>
      </div>
    </div>
  </div>

  <!-- Modal Save Scene -->
  <div id="saveSceneModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Salva Scena</h2>
        <button class="close-modal" onclick="closeSaveSceneModal()">&times;</button>
      </div>
      <div class="form-group">
        <label for="sceneName">Nome Scena:</label>
        <input type="text" id="sceneName" placeholder="Es: ModalitÃ  Cinema">
      </div>
      <div class="form-group">
        <label for="sceneDescription">Descrizione (opzionale):</label>
        <textarea id="sceneDescription" rows="3" placeholder="Descrivi questa configurazione..."></textarea>
      </div>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="closeSaveSceneModal()">Annulla</button>
        <button class="btn btn-success" onclick="confirmSaveScene()">Salva Scena</button>
      </div>
    </div>
  </div>

  <script>
    class ControllerClient {
      constructor() {
        this.ws = null;
        this.displays = new Map();
        this.selectedDisplays = new Set();
        this.currentMode = 'global';
        this.scenes = this.loadScenes();
        this.commandHistory = [];
        this.renameTargetId = null;

        this.connect();
        this.setupEventListeners();
        this.renderScenes();
      }

      connect() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}`;

        console.log('Connessione controller a:', wsUrl);
        this.updateConnectionStatus(false, 'Connessione...');

        try {
          this.ws = new WebSocket(wsUrl);

          this.ws.onopen = () => {
            console.log('Controller WebSocket connesso');
            this.updateConnectionStatus(true, 'Connesso');
            this.register();
          };

          this.ws.onmessage = (event) => {
            this.handleMessage(event.data);
          };

          this.ws.onerror = (error) => {
            console.error('Errore WebSocket controller:', error);
            this.updateConnectionStatus(false, 'Errore');
          };

          this.ws.onclose = () => {
            console.log('Controller WebSocket disconnesso');
            this.updateConnectionStatus(false, 'Disconnesso');
            setTimeout(() => this.connect(), 3000);
          };

        } catch (error) {
          console.error('Errore creazione WebSocket controller:', error);
          this.updateConnectionStatus(false, 'Errore');
          setTimeout(() => this.connect(), 3000);
        }
      }

      register() {
        this.send({
          type: 'register',
          clientType: 'controller'
        });

        this.send({
          type: 'getStatus'
        });
      }

      handleMessage(data) {
        try {
          const message = JSON.parse(data);

          switch(message.type) {
            case 'displaysStatus':
              this.updateDisplaysList(message.displays);
              break;

            case 'displayConnected':
              this.addDisplay(message.display);
              break;

            case 'displayDisconnected':
              this.removeDisplay(message.displayId);
              break;

            case 'displayUpdated':
              this.updateDisplay(message.display);
              break;

            case 'commandLog':
              this.addCommandLog(message.log);
              break;

            case 'configExported':
              this.downloadConfig(message.config);
              break;

            case 'ping':
              this.send({ type: 'pong' });
              break;

            default:
              console.log('Messaggio non gestito:', message.type);
          }
        } catch (error) {
          console.error('Errore parsing messaggio controller:', error);
        }
      }

      send(message) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          this.ws.send(JSON.stringify(message));
        } else {
          console.warn('WebSocket non connesso');
        }
      }

      updateConnectionStatus(connected, text) {
        const indicator = document.getElementById('connectionIndicator');
        const statusText = document.getElementById('connectionText');

        if (connected) {
          indicator.classList.add('connected');
        } else {
          indicator.classList.remove('connected');
        }

        statusText.textContent = text;
      }

      updateDisplaysList(displays) {
        displays.forEach(display => {
          this.displays.set(display.id, display);
        });

        this.renderDisplays();
      }

      addDisplay(display) {
        this.displays.set(display.id, display);
        this.renderDisplays();
        this.showNotification(`Display connesso: ${display.name}`);
      }

      removeDisplay(displayId) {
        this.displays.delete(displayId);
        this.selectedDisplays.delete(displayId);
        this.renderDisplays();
      }

      updateDisplay(display) {
        this.displays.set(display.id, display);
        this.renderDisplays();
      }

      renderDisplays() {
        const grid = document.getElementById('displaysGrid');
        const emptyState = document.getElementById('emptyState');
        const count = document.getElementById('displayCount');

        count.textContent = this.displays.size;

        if (this.displays.size === 0) {
          emptyState.style.display = 'block';
          grid.innerHTML = '';
          grid.appendChild(emptyState);
          return;
        }

        emptyState.style.display = 'none';
        grid.innerHTML = '';

        this.displays.forEach((display) => {
          const card = this.createDisplayCard(display);
          grid.appendChild(card);
        });
      }

      createDisplayCard(display) {
        const card = document.createElement('div');
        card.className = 'display-card';
        card.dataset.displayId = display.id;

        if (!display.connected) {
          card.classList.add('offline');
        }

        if (this.selectedDisplays.has(display.id)) {
          card.classList.add('selected');
        }

        card.innerHTML = `
          <div class="display-header">
            ${this.currentMode === 'multiple' ? `
              <input type="checkbox" class="display-checkbox" ${this.selectedDisplays.has(display.id) ? 'checked' : ''}>
            ` : '<div></div>'}
            <div class="display-status ${display.connected ? 'online' : 'offline'}">
              <span>${display.connected ? 'ğŸŸ¢ Online' : 'ğŸ”´ Offline'}</span>
            </div>
          </div>

          <div class="display-preview" style="background-color: ${display.color}"></div>

          <div class="display-info">
            <h3>${display.name}</h3>
            <div class="display-id">${display.id.substring(0, 24)}...</div>
            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.5rem;">
              Colore: <span style="font-family: monospace;">${display.color}</span>
            </div>
          </div>

          <div class="display-actions">
            <button class="btn btn-secondary btn-small rename-btn">
              âœï¸ Rinomina
            </button>
            <button class="btn btn-danger btn-small disconnect-btn" ${!display.connected ? 'disabled' : ''}>
              ğŸ”Œ Disconnetti
            </button>
          </div>
        `;

        // Event listeners
        if (this.currentMode === 'multiple') {
          const checkbox = card.querySelector('.display-checkbox');
          checkbox.addEventListener('change', (e) => {
            e.stopPropagation();
            if (e.target.checked) {
              this.selectedDisplays.add(display.id);
            } else {
              this.selectedDisplays.delete(display.id);
            }
            this.renderDisplays();
          });
        }

        if (this.currentMode === 'single') {
          card.addEventListener('click', () => {
            this.selectedDisplays.clear();
            this.selectedDisplays.add(display.id);
            this.renderDisplays();
          });
        }

        card.querySelector('.rename-btn').addEventListener('click', (e) => {
          e.stopPropagation();
          this.openRenameModal(display.id, display.name);
        });

        card.querySelector('.disconnect-btn').addEventListener('click', (e) => {
          e.stopPropagation();
          if (confirm(`Disconnettere il display "${display.name}"?`)) {
            this.disconnectDisplay(display.id);
          }
        });

        return card;
      }

      setupEventListeners() {
        // Mode buttons
        document.querySelectorAll('.mode-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            this.currentMode = btn.dataset.mode;
            this.selectedDisplays.clear();
            this.renderDisplays();
          });
        });

        // Color picker sync
        const colorPicker = document.getElementById('globalColorPicker');
        const hexInput = document.getElementById('colorHexInput');

        colorPicker.addEventListener('input', (e) => {
          hexInput.value = e.target.value;
        });

        hexInput.addEventListener('input', (e) => {
          let value = e.target.value;
          if (value.startsWith('#') && (value.length === 7 || value.length === 4)) {
            colorPicker.value = value;
          }
        });

        // Apply color
        document.getElementById('applyColorBtn').addEventListener('click', () => {
          this.applyColor(hexInput.value);
        });

        // Preset colors
        document.querySelectorAll('.preset-color').forEach(preset => {
          preset.addEventListener('click', () => {
            const color = preset.dataset.color;
            colorPicker.value = color;
            hexInput.value = color;
            this.applyColor(color);
          });
        });

        // Actions
        document.getElementById('exportConfigBtn').addEventListener('click', () => {
          this.exportConfig();
        });

        document.getElementById('importConfigBtn').addEventListener('click', () => {
          this.importConfig();
        });

        document.getElementById('saveSceneBtn').addEventListener('click', () => {
          this.openSaveSceneModal();
        });

        document.getElementById('refreshDisplaysBtn').addEventListener('click', () => {
          this.send({ type: 'getStatus' });
        });
      }

      applyColor(color) {
        if (!color.startsWith('#') || (color.length !== 7 && color.length !== 4)) {
          this.showNotification('Formato colore non valido', 'error');
          return;
        }

        let targetIds;

        if (this.currentMode === 'global') {
          targetIds = 'all';
        } else if (this.currentMode === 'multiple' || this.currentMode === 'single') {
          if (this.selectedDisplays.size === 0) {
            this.showNotification('Seleziona almeno un display', 'error');
            return;
          }
          targetIds = Array.from(this.selectedDisplays);
        }

        this.send({
          type: 'colorChange',
          targetIds: targetIds,
          payload: { color: color }
        });
      }

      openRenameModal(displayId, currentName) {
        this.renameTargetId = displayId;
        document.getElementById('newDisplayName').value = currentName;
        document.getElementById('renameModal').classList.add('active');
      }

      disconnectDisplay(displayId) {
        this.send({
          type: 'disconnect',
          targetIds: [displayId],
          payload: {}
        });
      }

      exportConfig() {
        const config = {
          displays: Array.from(this.displays.values()),
          scenes: this.scenes,
          exportedAt: new Date().toISOString()
        };

        this.downloadConfig(config);
      }

      downloadConfig(config) {
        const dataStr = JSON.stringify(config, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `control-square-config-${Date.now()}.json`;
        link.click();
        URL.revokeObjectURL(url);

        this.showNotification('Configurazione esportata!');
      }

      importConfig() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json';

        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const config = JSON.parse(event.target.result);

              if (config.scenes) {
                this.scenes = config.scenes;
                this.saveScenes();
                this.renderScenes();
              }

              this.showNotification('Configurazione importata!');
            } catch (error) {
              console.error('Errore import:', error);
              this.showNotification('Errore nell\'importazione', 'error');
            }
          };

          reader.readAsText(file);
        };

        input.click();
      }

      openSaveSceneModal() {
        if (this.displays.size === 0) {
          this.showNotification('Nessun display connesso', 'error');
          return;
        }

        document.getElementById('saveSceneModal').classList.add('active');
      }

      saveScene(name, description) {
        const scene = {
          id: 'scene-' + Date.now(),
          name: name,
          description: description,
          displays: Array.from(this.displays.values()).map(d => ({
            id: d.id,
            name: d.name,
            color: d.color
          })),
          createdAt: new Date().toISOString()
        };

        this.scenes.push(scene);
        this.saveScenes();
        this.renderScenes();
        this.showNotification('Scena salvata!');
      }

      loadScene(scene) {
        this.send({
          type: 'loadScene',
          scene: scene
        });

        this.showNotification(`Scena "${scene.name}" caricata!`);
      }

      deleteScene(sceneId) {
        this.scenes = this.scenes.filter(s => s.id !== sceneId);
        this.saveScenes();
        this.renderScenes();
        this.showNotification('Scena eliminata');
      }

      loadScenes() {
        const saved = localStorage.getItem('controlSquareScenes');
        return saved ? JSON.parse(saved) : [];
      }

      saveScenes() {
        localStorage.setItem('controlSquareScenes', JSON.stringify(this.scenes));
      }

      renderScenes() {
        const list = document.getElementById('scenesList');
        const emptyState = document.getElementById('scenesEmptyState');

        if (this.scenes.length === 0) {
          emptyState.style.display = 'block';
          list.innerHTML = '';
          list.appendChild(emptyState);
          return;
        }

        emptyState.style.display = 'none';
        list.innerHTML = '';

        this.scenes.forEach(scene => {
          const item = document.createElement('div');
          item.className = 'scene-item';

          const colors = scene.displays.map(d => d.color).slice(0, 5);

          item.innerHTML = `
            <div class="scene-name">${scene.name}</div>
            <div class="scene-displays">${scene.displays.length} display</div>
            ${scene.description ? `<div class="scene-displays">${scene.description}</div>` : ''}
            <div class="scene-preview">
              ${colors.map(c => `<div class="scene-color-dot" style="background-color: ${c}"></div>`).join('')}
            </div>
            <div class="scene-actions">
              <button class="btn btn-primary btn-small load-scene-btn">Carica</button>
              <button class="btn btn-danger btn-small delete-scene-btn">Elimina</button>
            </div>
          `;

          item.querySelector('.load-scene-btn').addEventListener('click', () => {
            this.loadScene(scene);
          });

          item.querySelector('.delete-scene-btn').addEventListener('click', () => {
            if (confirm(`Eliminare la scena "${scene.name}"?`)) {
              this.deleteScene(scene.id);
            }
          });

          list.appendChild(item);
        });
      }

      addCommandLog(log) {
        this.commandHistory.unshift(log);
        if (this.commandHistory.length > 50) {
          this.commandHistory.pop();
        }

        const logContainer = document.getElementById('logEntries');
        logContainer.innerHTML = '';

        this.commandHistory.slice(0, 20).forEach(entry => {
          const logEntry = document.createElement('div');
          logEntry.className = 'log-entry';

          const timestamp = new Date(entry.timestamp).toLocaleTimeString();
          const targets = entry.targetIds === 'all' ? 'tutti' : `${entry.targetIds.length} display`;

          logEntry.innerHTML = `
            <div class="log-timestamp">${timestamp}</div>
            <div class="log-content">
              <strong>${entry.type}</strong> â†’ ${targets}
              ${entry.payload.color ? `| Colore: ${entry.payload.color}` : ''}
            </div>
          `;

          logContainer.appendChild(logEntry);
        });
      }

      showNotification(message, type = 'success') {
        const notification = document.createElement('div');
        notification.textContent = message;

        const bgColor = type === 'error' ? 'var(--danger-color)' : 'var(--success-color)';

        notification.style.cssText = `
          position: fixed;
          top: 2rem;
          right: 2rem;
          background: ${bgColor};
          color: white;
          padding: 1rem 1.5rem;
          border-radius: 0.5rem;
          font-weight: 600;
          z-index: 10000;
          animation: fadeIn 0.3s ease-out;
          box-shadow: var(--shadow-lg);
        `;

        document.body.appendChild(notification);

        setTimeout(() => {
          notification.style.opacity = '0';
          notification.style.transition = 'opacity 0.3s ease-out';
          setTimeout(() => {
            document.body.removeChild(notification);
          }, 300);
        }, 3000);
      }
    }

    // Modal functions (global scope for onclick handlers)
    function closeRenameModal() {
      document.getElementById('renameModal').classList.remove('active');
    }

    function confirmRename() {
      const newName = document.getElementById('newDisplayName').value.trim();
      if (!newName) {
        alert('Inserisci un nome valido');
        return;
      }

      if (window.controller && window.controller.renameTargetId) {
        window.controller.send({
          type: 'rename',
          targetIds: [window.controller.renameTargetId],
          payload: { name: newName }
        });

        closeRenameModal();
      }
    }

    function closeSaveSceneModal() {
      document.getElementById('saveSceneModal').classList.remove('active');
    }

    function confirmSaveScene() {
      const name = document.getElementById('sceneName').value.trim();
      const description = document.getElementById('sceneDescription').value.trim();

      if (!name) {
        alert('Inserisci un nome per la scena');
        return;
      }

      if (window.controller) {
        window.controller.saveScene(name, description);
        closeSaveSceneModal();

        // Reset form
        document.getElementById('sceneName').value = '';
        document.getElementById('sceneDescription').value = '';
      }
    }

    // Initialize controller
    window.addEventListener('DOMContentLoaded', () => {
      window.controller = new ControllerClient();
    });

    // Close modals on outside click
    window.addEventListener('click', (e) => {
      if (e.target.classList.contains('modal')) {
        e.target.classList.remove('active');
      }
    });
  </script>
</body>
</html>
